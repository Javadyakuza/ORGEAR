"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.cloneInto = cloneInto;
exports.commit = commit;
exports.findLatestFileCommitHash = findLatestFileCommitHash;
exports.getDefinitionsDiff = getDefinitionsDiff;
exports.init = init;
exports.rebaseRepoMaster = rebaseRepoMaster;
exports.setLocalConfig = setLocalConfig;

var _which = _interopRequireDefault(require("which"));

var _node = require("./node");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getGitPath() {
  try {
    return await which('git');
  } catch (e) {
    throw new Error(`Unable to find ${'`'}git${'`'} installed on this system: ${e.message}`);
  }
}

function which(executable) {
  return new Promise((res, rej) => {
    (0, _which.default)(executable, (err, resolvedPath) => {
      if (err) {
        rej(err);
      } else {
        res(resolvedPath);
      }
    });
  });
}

async function add(repoPath, pathToAdd) {
  const gitPath = await getGitPath();

  try {
    await _node.child_process.spawnP(gitPath, ['add', pathToAdd], {
      cwd: repoPath
    });
  } catch (e) {
    throw new Error(`Error adding staged file(s) to git repo: ${e.message}`);
  }
}

async function commit(dirPath, message) {
  const gitPath = await getGitPath();

  try {
    await _node.child_process.spawnP(gitPath, ['commit', '-a', '-m', message], {
      cwd: dirPath
    });
  } catch (e) {
    console.error(e); //throw new Error(`Error creating a commit in git repo: ${e.message}`);
  }
}

async function setLocalConfig(dirPath, name, value) {
  const gitPath = await getGitPath();

  try {
    await _node.child_process.spawnP(gitPath, ['config', name, JSON.stringify(value)], {
      cwd: dirPath
    });
  } catch (e) {
    console.error(e); //throw new Error(`Error creating a commit in git repo: ${e.message}`);
  }
}

async function getDefinitionsDiff() {
  const gitPath = await getGitPath();

  try {
    // const {stdout: branchName} = await child_process.spawnP(gitPath, [
    //   'rev-parse',
    //   '--abbrev-ref',
    //   'HEAD',
    // ]);
    let {
      stdout
    } = await _node.child_process.spawnP(gitPath, ['diff', 'origin/master', '--name-only']);
    console.log(stdout);

    if (stdout.split('\n').filter(o => o.startsWith('definitions/')).length === 0) {
      // We are probably already on master, so compare to the last commit.
      const {
        stdout: headDiff
      } = await _node.child_process.spawnP(gitPath, ['diff', 'HEAD~1', '--name-only']);
      stdout = headDiff;
    }

    return stdout.split('\n');
  } catch (e) {
    console.error('Unable to find diffs!');
    console.error(e);
    return [];
  }
}

async function cloneInto(gitURL, destDirPath) {
  const gitPath = await getGitPath();

  try {
    await _node.child_process.spawnP(gitPath, ['clone', gitURL, destDirPath]);
  } catch (e) {
    throw new Error(`Error cloning repo: ${e.message}`);
  }
}

async function init(dirPath) {
  const gitPath = await getGitPath();

  try {
    await _node.child_process.spawnP(gitPath, ['init'], {
      cwd: dirPath
    });
  } catch (e) {
    throw new Error(`Error init-ing git repo: ${e.message}`);
  }
}

async function findLatestFileCommitHash(repoPath, filePath) {
  const gitPath = await getGitPath();

  try {
    const {
      stdout
    } = await _node.child_process.spawnP(gitPath, ['log', '--pretty=%H', filePath], {
      cwd: repoPath
    });
    return stdout.trim();
  } catch (e) {
    throw new Error(`Error finding latest commit hash for ${filePath}: ${e.message}`);
  }
}

async function rebaseRepoMaster(repoDirPath) {
  const gitPath = await getGitPath();
  await _node.child_process.spawnP(gitPath, ['checkout', 'master'], {
    cwd: repoDirPath
  }).catch(({
    stderr
  }) => {
    throw new Error('Error checking out the `master` branch of the following repo:\n' + `${repoDirPath}\n\n${stderr}`);
  });

  try {
    await _node.child_process.execFileP(gitPath, ['pull', '--rebase'], {
      cwd: repoDirPath
    });
  } catch (e) {
    const {
      stderr
    } = e;
    throw new Error('Error rebasing the `master` branch of the following repo:\n' + `${repoDirPath}\n\n${stderr}`);
  }
}