"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findEnvDef = void 0;
exports.getEnvDefVersionHash = getEnvDefVersionHash;
exports.getEnvDefs = void 0;

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _cacheRepoUtils = require("./cacheRepoUtils");

var _node = require("./node");

var _ValidationError = require("./ValidationError");

var _flowVersion = require("./flowVersion");

var _libDefs = require("./libDefs");

var _git = require("./git");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getEnvDefs = async () => {
  const definitionsDir = _path.default.join((0, _cacheRepoUtils.getCacheRepoDir)(), 'definitions');

  const envDefsDirPath = _path.default.join(definitionsDir, 'environments');

  const dirItems = await _node.fs.readdir(envDefsDirPath);
  const errors = [];
  const proms = dirItems.map(async itemName => {
    // If a user opens definitions dir in finder it will create `.DS_Store`
    // which will need to be excluded while parsing
    if (itemName === '.DS_Store') return;

    try {
      return await getSingleEnvDef(itemName, envDefsDirPath);
    } catch (e) {
      errors.push(e);
    }
  });
  const settled = await Promise.all(proms);

  if (errors.length) {
    throw errors;
  }

  return [...settled].filter(Boolean).flat();
};

exports.getEnvDefs = getEnvDefs;

const getSingleEnvDef = async (defName, envDefPath) => {
  const itemPath = _path.default.join(envDefPath, defName);

  const itemStat = await _node.fs.stat(itemPath);

  if (itemStat.isDirectory()) {
    // itemPath must be an env dir
    return await extractEnvDefs(itemPath, defName);
  } else {
    throw new _ValidationError.ValidationError(`Expected only directories to be present in this directory.`);
  }
};

async function extractEnvDefs(envDirPath, defName) {
  const envDefFileName = `${defName}.js`;
  const envDirItems = await _node.fs.readdir(envDirPath);
  const commonTestFiles = [];
  const parsedFlowDirs = [];
  envDirItems.forEach(envDirItem => {
    const envDirItemPath = _path.default.join(envDirPath, envDirItem);

    const envDirItemStat = _node.fs.statSync(envDirItemPath);

    if (envDirItemStat.isFile()) {
      const isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(envDirItem);

      if (isValidTestFile) commonTestFiles.push(envDirItemPath);
    } else if (envDirItemStat.isDirectory()) {
      const parsedFlowDir = (0, _flowVersion.parseDirString)(envDirItem);
      parsedFlowDirs.push([envDirItemPath, parsedFlowDir]);
    } else {
      throw new _ValidationError.ValidationError('Unexpected directory item');
    }
  });

  if (!(0, _flowVersion.disjointVersionsAll)(parsedFlowDirs.map(([_, ver]) => ver))) {
    throw new _ValidationError.ValidationError('Flow versions not disjoint!');
  }

  if (parsedFlowDirs.length === 0) {
    throw new _ValidationError.ValidationError('No libdef files found!');
  }

  const envDefs = [];
  await Promise.all(parsedFlowDirs.map(async ([flowDirPath, flowVersion]) => {
    const testFilePaths = [...commonTestFiles];
    let libDefFilePath = null;
    (await _node.fs.readdir(flowDirPath)).forEach(flowDirItem => {
      const flowDirItemPath = _path.default.join(flowDirPath, flowDirItem);

      const flowDirItemStat = _node.fs.statSync(flowDirItemPath);

      if (flowDirItemStat.isFile()) {
        if (_path.default.extname(flowDirItem) === '.swp') {
          return;
        } // Is this the env def file?


        if (flowDirItem === envDefFileName) {
          libDefFilePath = _path.default.join(flowDirPath, flowDirItem);
          return;
        } // Is this a test file?


        const isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(flowDirItem);

        if (isValidTestFile) {
          testFilePaths.push(flowDirItemPath);
          return;
        }

        throw new _ValidationError.ValidationError(`Unexpected file: ${envDefFileName}. This directory can only contain test files ` + `or a env def file named \`${envDefFileName}\`.`);
      } else {
        throw new _ValidationError.ValidationError(`Unexpected sub-directory. This directory can only contain test ` + `files or a env def file named \`${envDefFileName}\`.`);
      }
    });

    if (libDefFilePath === null) {
      libDefFilePath = _path.default.join(flowDirPath, envDefFileName);
      throw new _ValidationError.ValidationError(`No env def file found. Looking for a file named ${envDefFileName}`);
    }

    envDefs.push({
      name: defName,
      flowVersion,
      path: libDefFilePath,
      testFilePaths
    });
  }));
  return envDefs;
}

const findEnvDef = (defName, flowVersion, useCacheUntil, envDefs) => {
  return envDefs.filter(def => {
    let filterMatch = def.name === defName;

    if (!filterMatch) {
      return false;
    }

    switch (def.flowVersion.kind) {
      case 'all':
        return true;

      case 'ranged':
      case 'specific':
        return _semver.default.satisfies((0, _flowVersion.toSemverString)(flowVersion), (0, _flowVersion.toSemverString)(def.flowVersion));

      default:
        return true;
    }
  })[0];
};

exports.findEnvDef = findEnvDef;

async function getEnvDefVersionHash(repoDirPath, libDef) {
  const latestCommitHash = await (0, _git.findLatestFileCommitHash)(repoDirPath, _path.default.relative(repoDirPath, libDef.path));
  return `${latestCommitHash.substr(0, 10)}/${libDef.name}/flow_${(0, _flowVersion.toSemverString)(libDef.flowVersion)}`;
}