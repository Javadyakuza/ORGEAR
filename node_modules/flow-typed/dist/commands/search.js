"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._formatDefTable = _formatDefTable;
exports.name = exports.description = void 0;
exports.run = run;
exports.setup = setup;

var _libDefs = require("../lib/libDefs.js");

var _flowVersion = require("../lib/flowVersion");

var _table = require("table");

function _formatDefTable(defs) {
  const formatted = [['Name', 'Package Version', 'Flow Version']].concat(defs.map(def => {
    return [def.pkgName, def.pkgVersionStr, (0, _flowVersion.toSemverString)(def.flowVersion)];
  }));

  if (formatted.length === 1) {
    return 'No definitions found, sorry!';
  } else {
    return '\nFound definitions:\n' + (0, _table.table)(formatted);
  }
}

const name = 'search <term>';
exports.name = name;
const description = 'Perform a simple search (by name) of available libdefs';
exports.description = description;

function setup(yargs) {
  return yargs.positional('term', {
    describe: 'Please provide a term for which to search!',
    type: 'string'
  }).option({
    flowVersion: {
      alias: 'f',
      describe: 'The Flow version that fetched libdefs must be compatible with',
      type: 'string'
    }
  });
}

async function run(args) {
  let flowVersionStr;

  if (typeof args.flowVersion === 'string') {
    flowVersionStr = args.flowVersion;
  }

  const term = args.term;

  if (typeof term !== 'string') {
    throw new Error('term should be a string');
  }

  const defs = await (0, _libDefs.getCacheLibDefs)(process.stdout);
  const filtered = (0, _libDefs.filterLibDefs)(defs, {
    type: 'fuzzy',
    term,
    flowVersionStr
  });
  console.log(_formatDefTable(filtered));
  return 0;
}