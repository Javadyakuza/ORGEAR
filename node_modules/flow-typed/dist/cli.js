#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runCLI = runCLI;

var _yargs = _interopRequireDefault(require("yargs"));

var _node = require("./lib/node");

var Install = _interopRequireWildcard(require("./commands/install"));

var CreateDef = _interopRequireWildcard(require("./commands/create-def"));

var CreateStub = _interopRequireWildcard(require("./commands/create-stub"));

var Outdated = _interopRequireWildcard(require("./commands/outdated"));

var RunTests = _interopRequireWildcard(require("./commands/runTests"));

var Search = _interopRequireWildcard(require("./commands/search"));

var Update = _interopRequireWildcard(require("./commands/update"));

var UpdateCache = _interopRequireWildcard(require("./commands/update-cache"));

var ValidateDefs = _interopRequireWildcard(require("./commands/validateDefs"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const identity = x => x;

function runCLI() {
  const commands = [CreateDef, CreateStub, Install, Outdated, RunTests, Search, Update, UpdateCache, ValidateDefs];
  commands.reduce((cmdYargs, cmd) => cmdYargs.command(cmd.name, cmd.description, cmd.setup || identity, args => cmd // $FlowExpectedError[extra-arg] cmd.run expects only one arg
  .run(args, _yargs.default).catch(err => {
    if (err.stack) {
      console.log('UNCAUGHT ERROR: %s', err.stack);
    } else if (typeof err === 'object' && err !== null) {
      console.log('UNCAUGHT ERROR: %s', JSON.stringify(err, null, 2));
    } else {
      console.log('UNCAUGHT ERROR:', err);
    }

    process.exit(1);
  }).then(code => process.exit(code))), _yargs.default).demand(1).strict().recommendCommands().help('h').alias('h', 'help').argv;
}
/**
 * Look to see if the CWD is within an npm project. If it is, and that project
 * has a flow-typed CLI `npm install`ed, use that version instead of the global
 * version of the CLI.
 */


if (require.main === module) {
  const CWD = process.cwd();
  let currDir = CWD;
  let lastDir = null;
  let run = runCLI;

  while (currDir !== lastDir) {
    const localCLIPath = _node.path.join(currDir, 'node_modules', '.bin', 'flow-typed');

    try {
      if (_node.fs.statSync(localCLIPath).isFile()) {
        run = require.call(null, localCLIPath).runCLI;
        break;
      }
    } catch (e) {
      /* File doesn't exist, move up a dir... */
    }

    lastDir = currDir;
    currDir = _node.path.resolve(currDir, '..');
  }

  run();
}