"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._cacheRepoEnsureToken = exports._REMOTE_REPO_URL = exports._CACHE_REPO_EXPIRY = exports.CACHE_REPO_EXPIRY = void 0;
exports._clearCustomCacheDir = clearCustomCacheDir;
exports._getCacheRepoGitDir = getCacheRepoGitDir;
exports._getLastUpdatedFile = getLastUpdatedFile;
exports._setCustomCacheDir = setCustomCacheDir;
exports.ensureCacheRepo = ensureCacheRepo;
exports.getCacheRepoDir = getCacheRepoDir;
exports.verifyCLIVersion = verifyCLIVersion;

var _fileUtils = require("./fileUtils");

var _git = require("./git");

var _node = require("./node");

var _semver = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CACHE_REPO_EXPIRY = 1000 * 60; // 1 minute

exports._CACHE_REPO_EXPIRY = exports.CACHE_REPO_EXPIRY = CACHE_REPO_EXPIRY;
const REMOTE_REPO_URL = 'https://github.com/flowtype/flow-typed.git';
exports._REMOTE_REPO_URL = REMOTE_REPO_URL;

async function cloneCacheRepo() {
  await (0, _fileUtils.mkdirp)(getCacheRepoDir());

  try {
    await (0, _git.cloneInto)(REMOTE_REPO_URL, getCacheRepoDir());
  } catch (e) {
    console.error('ERROR: Unable to clone local cache repo!');
    throw e;
  }

  await _node.fs.writeFile(getLastUpdatedFile(), String(Date.now()));
}

let customCacheDir = null;

function getCacheDir() {
  return customCacheDir === null ? _node.path.join(_node.os.homedir(), '.flow-typed') : customCacheDir;
}

function clearCustomCacheDir() {
  customCacheDir = null;
}

function setCustomCacheDir(dir) {
  customCacheDir = dir;
}

function getCacheRepoGitDir() {
  return _node.path.join(getCacheRepoDir(), '.git');
}

function getLastUpdatedFile() {
  return _node.path.join(getCacheRepoDir(), 'lastUpdated');
}

async function rebaseCacheRepo() {
  if ((await _node.fs.exists(getCacheRepoDir())) && (await _node.fs.exists(getCacheRepoGitDir()))) {
    try {
      await (0, _git.rebaseRepoMaster)(getCacheRepoDir());
    } catch (e) {
      console.error('ERROR: Unable to rebase the local cache repo. ' + e.message);
      return false;
    }

    await _node.fs.writeFile(getLastUpdatedFile(), String(Date.now()));
    return true;
  } else {
    await cloneCacheRepo();
    return true;
  }
}
/**
 * Ensure that the CACHE_REPO_DIR exists and is recently rebased.
 * (else: create/rebase it)
 */


const cacheRepoEnsureToken = {
  lastEnsured: 0,
  pendingEnsurance: Promise.resolve()
};
exports._cacheRepoEnsureToken = cacheRepoEnsureToken;

async function ensureCacheRepo(cacheRepoExpiry = CACHE_REPO_EXPIRY) {
  // Only re-run rebase checks if a check hasn't been run in the last 5 minutes
  if (cacheRepoEnsureToken.lastEnsured + 5 * 1000 * 60 >= Date.now()) {
    return cacheRepoEnsureToken.pendingEnsurance;
  }

  cacheRepoEnsureToken.lastEnsured = Date.now();
  const prevEnsurance = cacheRepoEnsureToken.pendingEnsurance;
  return cacheRepoEnsureToken.pendingEnsurance = prevEnsurance.then(() => async function () {
    const repoDirExists = _node.fs.exists(getCacheRepoDir());

    const repoGitDirExists = _node.fs.exists(getCacheRepoGitDir());

    if (!(await repoDirExists) || !(await repoGitDirExists)) {
      console.log(`• flow-typed cache not found, fetching from GitHub...`);
      await cloneCacheRepo();
    } else {
      let lastUpdated = 0;

      if (await _node.fs.exists(getLastUpdatedFile())) {
        // If the LAST_UPDATED_FILE has anything other than just a number in
        // it, just assume we need to update.
        const lastUpdatedRaw = await _node.fs.readFile(getLastUpdatedFile());
        const lastUpdatedNum = parseInt(lastUpdatedRaw, 10);

        if (String(lastUpdatedNum) === String(lastUpdatedRaw)) {
          lastUpdated = lastUpdatedNum;
        }
      }

      if (lastUpdated + cacheRepoExpiry < Date.now()) {
        console.log('• rebasing flow-typed cache...');
        const rebaseSuccessful = await rebaseCacheRepo();

        if (!rebaseSuccessful) {
          console.log("\nNOTE: Unable to rebase local cache! If you don't currently " + "have internet connectivity, no worries -- we'll update the " + 'local cache the next time you do.\n');
        }
      }
    }
  }());
}

function getCacheRepoDir() {
  return _node.path.join(getCacheDir(), 'repo');
}

async function verifyCLIVersion() {
  var _semver$coerce;

  const metadataPath = _node.path.join(getCacheRepoDir(), 'definitions', '.cli-metadata.json');

  const metadata = await _node.fs.readJson(metadataPath);
  const compatibleCLIRange = metadata.compatibleCLIRange;

  if (!compatibleCLIRange) {
    throw new Error(`Unable to find the 'compatibleCLIRange' property in ${metadataPath}. ` + `You might need to update your flow-typed CLI to the latest version.`);
  }

  const thisCLIPkgJsonPath = _node.path.join(__dirname, '..', '..', 'package.json');

  const thisCLIPkgJson = await _node.fs.readJson(thisCLIPkgJsonPath);
  const thisCLIVersion = thisCLIPkgJson.version;

  if (!_semver.default.satisfies((_semver$coerce = _semver.default.coerce(thisCLIVersion)) !== null && _semver$coerce !== void 0 ? _semver$coerce : thisCLIVersion, compatibleCLIRange)) {
    throw new Error(`Please upgrade your flow-typed CLI! This CLI is version ` + `${thisCLIVersion}, but the latest flow-typed definitions are only ` + `compatible with flow-typed@${compatibleCLIRange}`);
  }
}