pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "./DAO.tsol";
import "./libraries/DAOErrors.tsol";
import "./interfaces/IDAO.tsol";
import "./interfaces/IDAORoot.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "./libraries/Gas.tsol";
import "./structures/DAOConfigurationStruct.tsol";

contract DAORoot is DAOConfigurationStruct, IDAORoot{

    event newDAODepoyed(string _name, string _logo, address _address, address _admin, uint256 _daoId);
    event DAORootAdminTransferreq(address _oldAdmin, address _newAdmin);
    event DAORootAdminTransfered(address _oldAdmin, address _newAdmin);
    event DAOCodeUpdated();

    address static admin;
    uint32 static _nonce;

    TvmCell public DaoCode;
    TvmCell public ProposalCode;
    TvmCell public Tip3VoteWalletCode;
    uint256 public TotalDaos;
    address public pendingAdmin;

    constructor(TvmCell _DaoCode,TvmCell _ProposalCode,TvmCell _Tip3VoteWalletCode) public {
        require(tvm.pubkey() == msg.pubkey(), DaoErrors.NOT_ADMIN);
        tvm.accept();
        DaoCode = _DaoCode;
        ProposalCode = _ProposalCode;
        Tip3VoteWalletCode = _Tip3VoteWalletCode;
    }

    modifier onlyAdmin () {
        require(msg.sender == admin , DaoErrors.NOT_ADMIN);
        _;
    } 

    // this function deploys A dao 
    function DeployDao(DaoConfig _DaoConfig) public override internalMsg{
        // chaking the msg.value 
        require(msg.value >= Gas.MAIN_VALUE, DaoErrors.VALUE_TOO_LOW);
        // reserving the contract value 
        tvm.rawReserve(0, 4);
        // deploying the dao 
        address daoAddr = new DAO {
            stateInit : _buildDaoStatInit(TotalDaos, msg.sender),
            value : 0,
            flag : MsgFlag.ALL_NOT_RESERVED
        }(
            _DaoConfig,
            ProposalCode,
            Tip3VoteWalletCode

        );
        emit newDAODepoyed(_DaoConfig.Name,_DaoConfig.Logo,daoAddr, msg.sender,TotalDaos);
        TotalDaos++;
    }

    // -- admin functions -- //
    // this function chages the Dao code 
    function updateDaoCode(TvmCell _DaoCode) public onlyAdmin override {
        // in the octus we hade the onCodeChage handler but i don't see any resson to apply this here
        tvm.accept();
        // emotitng the event 
        emit DAOCodeUpdated();
        // setting the stae variable
        DaoCode = _DaoCode;
    }

    function transferAdmin(address _newAdmin) public onlyAdmin override {
        // accepting to pay the fees
        tvm.accept();
        // emiting the vent 
        emit DAORootAdminTransferreq(admin , _newAdmin);
        // setting the stte variable
        pendingAdmin = _newAdmin;
    }
    function acceptBeingAdmin() public override{
        // checking f the pending admin is calling 
        require(msg.sender == pendingAdmin , DaoErrors.NOT_PENDING_ADMIN);
        // reserving the contract value , the incomming message must be flag : 1 or this func will fail 
        tvm.rawReserve(0, 4);
        // emiting the event 
        emit DAORootAdminTransfered(admin , msg.sender);
        // setting the state variables
        pendingAdmin = address(0);
        admin = msg.sender;
        admin.transfer({value: 0, flag : MsgFlag.REMAINING_GAS});
    }
    // -- admin functions -- //

    // -- get function -- //
    function getAdmin() public override view returns(address admin_){
        return admin;
    }
        // this function calculates the daoranch address 
    function expectedDaoAddress (uint32 _daoId, address _admin_) public override view returns(address){
        return address(tvm.hash(_buildDaoStatInit(_daoId, _admin_)));
    }

    function _buildDaoStatInit(uint256 _daoId, address _admin_) private view returns(TvmCell){
        return tvm.buildStateInit({
            contr: DAO,
            varInit: {
                daoId: _daoId,
                admin: _admin_,
                DaoRoot : address(this)
            },
            pubkey: 0,
            code: DaoCode
        });
    }
    // -- get function -- //

 }