"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyDir = copyDir;
exports.copyFile = copyFile;
exports.getFilesInDir = getFilesInDir;
exports.mkdirp = mkdirp;
exports.recursiveRmdir = recursiveRmdir;
exports.searchUpDirPath = searchUpDirPath;

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _node = require("./node.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const P = Promise;

function copyDir(srcPath, destPath) {
  return new Promise((res, rej) => {
    _node.fs.copy(srcPath, destPath, err => {
      if (err) {
        rej(err);
      } else {
        res();
      }
    });
  });
}

function copyFile(srcPath, destPath, preProcessor) {
  return new Promise((res, rej) => {
    if (preProcessor) {
      const content = _node.fs.readFileSync(srcPath, 'utf-8');

      _node.fs.writeFile(destPath, preProcessor(content), err => {
        if (err) {
          rej(err);
        } else {
          res();
        }
      });
    } else {
      _node.fs.copyFile(srcPath, destPath, err => {
        if (err) {
          rej(err);
        } else {
          res();
        }
      });
    }
  });
}

async function getFilesInDir(dirPath, recursive = false) {
  let dirItems = await _node.fs.readdir(dirPath);
  let dirItemStats = await P.all(dirItems.map(item => _node.fs.stat(_node.path.join(dirPath, item))));
  const installedLibDefs = new Set();
  await P.all(dirItems.map(async (itemName, idx) => {
    const itemStat = dirItemStats[idx];

    if (itemStat.isFile()) {
      installedLibDefs.add(itemName);
    } else if (recursive && itemStat.isDirectory()) {
      const itemPath = _node.path.join(dirPath, itemName);

      const subDirFiles = await getFilesInDir(itemPath, recursive);
      subDirFiles.forEach(subItemName => installedLibDefs.add(_node.path.join(itemName, subItemName)));
    }
  }));
  return installedLibDefs;
}

function mkdirp(path) {
  return (0, _mkdirp.default)(path);
}

async function recursiveRmdir(dirPath) {
  let dirItems = await _node.fs.readdir(dirPath);
  let dirItemStats = await P.all(dirItems.map(item => _node.fs.stat(_node.path.join(dirPath, item))));
  await P.all(dirItems.map(async (itemName, idx) => {
    const itemStat = dirItemStats[idx];

    const itemPath = _node.path.join(dirPath, itemName);

    if (itemStat.isFile()) {
      await _node.fs.unlink(itemPath);
    } else {
      await recursiveRmdir(itemPath);
      await _node.fs.rmdir(itemPath).catch(err => {
        if (err.code === 'ENOENT') {
          // Ignore ENOENT error
          // it's okay if the files are already removed
          return;
        }

        throw err;
      });
    }
  }));
  return _node.fs.rmdir(dirPath);
}

async function searchUpDirPath(startDir, testFn) {
  let currDir = startDir;
  let lastDir = null;

  while (currDir !== lastDir) {
    if (await testFn(currDir)) {
      return currDir;
    }

    lastDir = currDir;
    currDir = _node.path.resolve(currDir, '..');
  }

  return null;
}